#################################################################################
# ngBot - MySQL Manager Plug-in                                                 #
#################################################################################
#
# Description:
# - Provides a centralized MySQL database interface for other pzs-ng plugins.
# - Manages multiple named connections.
# - Offers a high-level API for database operations.
# - Handles automatic connections and reconnections.
#
# Version: 1.0.0
# Author: ZarTek-Creole
# URL: https://github.com/ZarTek-Creole/ng-mysql-manager
#
# Requirements:
# - mysqltcl package (http://www.xdobry.de/mysqltcl/)
# - Tcl 8.6+
#
# Installation:
# 1. Install mysqltcl package.
# 2. Configure your database connections below in the 'connections' variable.
# 3. Add to eggdrop.conf BEFORE any plugins that use it:
#    source pzs-ng/plugins/MySQLManager.tcl
# 4. Restart or rehash eggdrop.
#
# --- USAGE DOCUMENTATION ---
#
# This plugin provides a public API under the namespace ::ngBot::ngSQL
# for other plugins to use.
#
# == Configuration ==
# To add or modify connections, edit the 'connections' variable in the
# CONFIGURATION SETTINGS section of this file. Each connection is a Tcl
# dictionary with a unique 'name'.
#
# Example:
#   variable connections [list \\
#       [dict create name "main_db" host "db.example.com" user "user1" pass "pass1" db "main_database" port 3306] \\
#       [dict create name "log_db"  host "db.example.com" user "user2" pass "pass2" db "log_database"  port 3306] \\
#   ]
#
# == API Procedures ==
#
# 1. ngSQL::sel {connection_name} {sql_query} [options]
#    - Executes a SELECT query.
#    - {connection_name}: The name of the connection to use (e.g., "nickdb").
#    - {sql_query}: The SQL query string.
#    - [options]: Optional. Can be "-dict" to return results as a list of dictionaries.
#    - Returns:
#        - A list of lists by default (each sublist is a row).
#        - A list of dictionaries if -dict is used.
#        - An empty list if there are no results.
#        - A list `[list "error" "message"]` on failure.
#
#    Example (list format):
#      set users [::ngBot::ngSQL::sel "nickdb" "SELECT ircUser, ftpUser FROM UserNames LIMIT 2"]
#      # $users might be: {{user1 ftp1} {user2 ftp2}}
#
#    Example (dict format):
#      set users [::ngBot::ngSQL::sel "nickdb" "SELECT ircUser, ftpUser FROM UserNames LIMIT 1" -dict]
#      # $users might be: {[dict create ircUser "user1" ftpUser "ftp1"]}
#      set ftpuser [dict get [lindex $users 0] "ftpUser"]
#
# 2. ngSQL::exec {connection_name} {sql_query}
#    - Executes an INSERT, UPDATE, or DELETE query.
#    - Returns:
#        - The number of affected rows on success.
#        - A list `[list "error" "message"]` on failure.
#
#    Example:
#      set safeNick [::ngBot::ngSQL::escape "nickdb" "NewNick"]
#      set affected [::ngBot::ngSQL::exec "nickdb" "UPDATE UserNames SET ircUser = '$safeNick' WHERE ftpUser = 'test'"]
#      if {[lindex $affected 0] ne "error"} {
#          putlog "Updated $affected rows."
#      }
#
# 3. ngSQL::escape {connection_name} {string_to_escape}
#    - Escapes a string to make it safe for SQL queries. Crucial to prevent SQL injection.
#    - Returns: The escaped string.
#
# 4. ngSQL::insertid {connection_name}
#    - Gets the ID generated by the most recent INSERT query on that connection.
#    - Returns: The last insert ID.
#
# 5. ngSQL::beginTransaction {connection_name}
#    - Disables autocommit and starts a new transaction.
#
# 6. ngSQL::commit {connection_name}
#    - Commits the current transaction and re-enables autocommit.
#
# 7. ngSQL::rollback {connection_name}
#    - Rolls back the current transaction and re-enables autocommit.
#
#    Transaction Example:
#      ::ngBot::ngSQL::beginTransaction "nickdb"
#      if {[catch {
#          ::ngBot::ngSQL::exec "nickdb" "UPDATE accounts SET balance = balance - 100 WHERE id = 1"
#          ::ngBot::ngSQL::exec "nickdb" "UPDATE accounts SET balance = balance + 100 WHERE id = 2"
#      } err]} {
#          putlog "Transaction failed: $err. Rolling back."
#          ::ngBot::ngSQL::rollback "nickdb"
#      } else {
#          ::ngBot::ngSQL::commit "nickdb"
#      }
#
# 8. ngSQL::info {connection_name} {option}
#    - Gets information from the database server.
#    - {option}: Can be `tables`, `databases`, `host`, `serverversion`, `serverversionid`.
#    - Returns: A list of tables/databases, or a string with the requested info.
#
# == Query Builder API (Recommended) ==
#
# This modern API uses objects to build queries, which is safer and more readable.
# It automatically handles SQL escaping.
#
# 1. ngSQL::select {connection_name} {table_name}
#    - Creates a SELECT query object.
#    - Returns: A query object with methods like `.where`, `.orderBy`, `.limit`, `.execute`.
#
#    Example:
#      set query [::ngBot::ngSQL::select "nickdb" "UserNames"]
#      $query where "ftpUser" "=" "some_user"
#      set result [$query execute] ;# Returns results like ngSQL::sel
#
# 2. ngSQL::update {connection_name} {table_name}
#    - Creates an UPDATE query object.
#
#    Example:
#      set query [::ngBot::ngSQL::update "nickdb" "UserNames"]
#      $query set [dict create ircUser "new_nick"]
#      $query where "ftpUser" "=" "old_user"
#      set affected_rows [$query execute]
#
# 3. ngSQL::insert {connection_name} {table_name}
#    - Creates an INSERT query object.
#
#    Example:
#      set query [::ngBot::ngSQL::insert "nickdb" "UserNames"]
#      $query values [dict create time [clock seconds] ircUser "new_user" ftpUser "new_ftp"]
#      # This will update time and ircUser if ftpUser already exists:
#      $query onDuplicateUpdate [dict create time [clock seconds] ircUser "new_user"]
#      set last_id [$query execute] ;# Returns last insert ID on success or update
#
# 4. ngSQL::delete {connection_name} {table_name}
#    - Creates a DELETE query object.
#
#    Example:
#      set query [::ngBot::ngSQL::delete "nickdb" "UserNames"]
#      $query where "ftpUser" "=" "user_to_delete"
#      set affected_rows [$query execute]
#
# == Legacy API (Functional, but not recommended for new code) ==
#
# The following procedures work with raw SQL strings. Use the Query Builder for new code.
#
# 1. ngSQL::sel {connection_name} {sql_query} [options]
# ...
#
# == Full Example in another plugin ==
#
#   proc GetUserSite {ircUser} {
#       set safeUser [::ngBot::ngSQL::escape "nickdb" $ircUser]
#       set result [::ngBot::ngSQL::sel "nickdb" "SELECT ftpUser FROM UserNames WHERE ircUser = '$safeUser'"]
#
#       if {[llength $result] == 0 || [lindex $result 0] eq "error"} {
#           return "User not found."
#       }
#       return "Site for $ircUser is [lindex $result 0 0]"
#   }
#
#################################################################################

# Internal implementation
namespace eval ::ngBot::plugin::MySQLManager {
  variable ns [namespace current]
  variable np [namespace qualifiers [namespace parent]]

  # Holds the connection handles [dict: name -> handle]
  variable db_handles [dict create]
  # Holds connection status [dict: name -> boolean]
  variable connected_status [dict create]
  # Holds transaction status [dict: name -> boolean]
  variable transaction_active [dict create]

  ### CONFIGURATION SETTINGS ################################################

  # Reconnect Settings
  variable maxRetries 3       ;# Max connection attempts
  variable retryDelay 5000    ;# Delay between retries (ms)

  #
  # Connections List:
  # - Add one or more dictionaries to this list.
  # - Each dictionary defines a connection with a unique 'name'.
  #
  variable connections [list \
    [dict create \
    name     "main_db" \
    host     "db.example.com" \
    user     "my_user" \
    pass     "my_password" \
    db       "main_database" \
    port     3306 \
  ] \
  [dict create \
  name     "log_db" \
  host     "127.0.0.1" \
  user     "log_user" \
  pass     "another_pass" \
  db       "bot_logs" \
  port     3306 \
] \
]

###########################################################################

bind evnt - prerehash [namespace current]::deinit
}

# Public API - Procs will be placed in this namespace
namespace eval ::ngBot::ngSQL {}

####
# Internal: ConnectToDatabase
# Establishes a single MySQL connection with retry logic
proc ::ngBot::plugin::MySQLManager::ConnectToDatabase {conn_dict} {
  variable maxRetries
  variable retryDelay
  variable db_handles
  variable connected_status

  dict with conn_dict {}

  if {[dict exists $connected_status $name] && [dict get $connected_status $name]} {
    return [dict get $db_handles $name]
  }

  for {set attempt 1} {$attempt <= $maxRetries} {incr attempt} {
    if {[catch {
      set handle [::mysql::connect \
        -host $host \
        -user $user \
        -password $pass \
        -db $db \
        -port $port]
    } errorMsg]} {
      putlog "\[ngBot\] MySQLManager Error ($name): Connection attempt $attempt failed - $errorMsg"
      if {$attempt < $maxRetries} {
        after $retryDelay
      } else {
        error "Could not connect to MySQL ($name): $errorMsg"
      }
      continue
    }

    if {$handle eq ""} {
      putlog "\[ngBot\] MySQLManager Error ($name): Received empty connection handle on attempt $attempt"
      if {$attempt < $maxRetries} {
        after $retryDelay
      } else {
        error "Could not connect to MySQL ($name): Received empty connection handle"
      }
      continue
    }

    ::mysql::autocommit $handle 1
    dict set db_handles $name $handle
    dict set connected_status $name 1
    putlog "\[ngBot\] MySQLManager: Successfully connected to '$name' (Attempt $attempt)"
    return $handle
  }
}

####
# Internal: CheckConnection
# Verifies and maintains a named database connection
proc ::ngBot::plugin::MySQLManager::CheckConnection {name} {
  variable db_handles
  variable connected_status
  variable connections

  if {![dict exists $db_handles $name] || ![dict get $connected_status $name]} {
    putlog "\[ngBot\] MySQLManager ($name): No existing or active connection found, attempting to connect."
    foreach conn_dict $connections {
      if {[dict get $conn_dict name] eq $name} {
        if {[catch {ConnectToDatabase $conn_dict} err]} {
          putlog "\[ngBot\] MySQLManager ($name): CheckConnection failed to re-establish connection: $err"
          return -code error "Failed to establish database connection for '$name': $err"
        }
        return [dict get $db_handles $name]
      }
    }
    return -code error "Connection '$name' not found in configuration."
  }

  set handle [dict get $db_handles $name]
  if {[catch {::mysql::ping $handle}]} {
    putlog "\[ngBot\] MySQLManager ($name): MySQL connection lost, attempting to reconnect."
    dict set connected_status $name 0

    foreach conn_dict $connections {
      if {[dict get $conn_dict name] eq $name} {
        if {[catch {ConnectToDatabase $conn_dict} err]} {
          putlog "\[ngBot\] MySQLManager ($name): CheckConnection failed to re-establish connection: $err"
          return -code error "Failed to re-establish database connection for '$name': $err"
        }
        return [dict get $db_handles $name]
      }
    }
  }

  return $handle
}

####
# Plugin Initialization
proc ::ngBot::plugin::MySQLManager::init {args} {
  variable connections

  putlog "\[ngBot\] Initializing MySQLManager (by ZarTek-Creole)"

  if {[catch {package require mysqltcl} errorMsg]} {
    error "MySQLManager failed to load mysqltcl package: $errorMsg"
  }

  putlog "\[ngBot\] MySQLManager: Attempting to establish configured connections..."
  foreach conn_dict $connections {
    if {[catch {ConnectToDatabase $conn_dict} errorMsg]} {
      # This is a critical error on startup
      error "MySQLManager connection failed for '[dict get $conn_dict name]': $errorMsg"
    }
  }

  putlog "\[ngBot\] MySQLManager: Initialization complete."
}

####
# Plugin Deinitialization
proc ::ngBot::plugin::MySQLManager::deinit {args} {
  variable db_handles
  variable connected_status
  variable transaction_active

  putlog "\[ngBot\] MySQLManager: Closing all database connections."

  dict for {name handle} $db_handles {
    if {[dict exists $connected_status $name] && [dict get $connected_status $name]} {
      catch {::mysql::close $handle}
      dict set connected_status $name 0
      putlog "\[ngBot\] MySQLManager: Closed connection '$name'."
    }
  }
  set db_handles [dict create]
  set connected_status [dict create]
  set transaction_active [dict create]
}


#--- PUBLIC API ---#

####
# ngSQL::sel
#
# Executes a SELECT query. Returns a list of lists, or a list of dictionaries.
#
proc ::ngBot::ngSQL::sel {conn_name sql_query args} {
  if {[catch {set handle [::ngBot::plugin::MySQLManager::CheckConnection $conn_name]} errorMsg]} {
    putlog "\[ngBot\] ngSQL::sel ($conn_name): Connection check failed: $errorMsg"
    return [list "error" "Connection check failed: $errorMsg"]
  }

  set format "-list"
  if {[lsearch -exact $args "-dict"] != -1} {
    set format "-dict"
  }

  if {[catch {set result_handle [::mysql::query $handle $sql_query]} errorMsg]} {
    putlog "\[ngBot\] ngSQL::sel ($conn_name) Error: $errorMsg (Query: $sql_query)"
    return [list "error" $errorMsg]
  }

  set result [list]
  if {$format eq "-dict"} {
    set columns [::mysql::col $result_handle -current name]
    while {[set row [::mysql::fetch $result_handle]] ne ""} {
      set row_dict [dict create]
      for {set i 0} {$i < [llength $columns]} {incr i} {
        dict set row_dict [lindex $columns $i] [lindex $row $i]
      }
      lappend result $row_dict
    }
    } else { ;# -list format
      while {[set row [::mysql::fetch $result_handle]] ne ""} {
      lappend result $row
    }
  }

  ::mysql::endquery $result_handle
  return $result
}

####
# ngSQL::exec
#
# Executes an INSERT, UPDATE, or DELETE query. Returns affected rows count.
#
proc ::ngBot::ngSQL::exec {conn_name sql_query} {
  if {[catch {set handle [::ngBot::plugin::MySQLManager::CheckConnection $conn_name]} errorMsg]} {
    putlog "\[ngBot\] ngSQL::exec ($conn_name): Connection check failed: $errorMsg"
    return [list "error" "Connection check failed: $errorMsg"]
  }

  if {[catch {::mysql::exec $handle $sql_query} result]} {
    putlog "\[ngBot\] ngSQL::exec ($conn_name) Error: $result (Query: $sql_query)"
    return [list "error" $result]
  }

  return $result
}

####
# ngSQL::escape
#
# Escapes a string for use in a query.
#
proc ::ngBot::ngSQL::escape {conn_name str_to_escape} {
  if {[catch {set handle [::ngBot::plugin::MySQLManager::CheckConnection $conn_name]} errorMsg]} {
    putlog "\[ngBot\] ngSQL::escape ($conn_name): Connection check failed: $errorMsg"
    return ""
  }
  return [::mysql::escape $handle $str_to_escape]
}

####
# ngSQL::insertid
#
# Gets the ID of the last inserted row.
#
proc ::ngBot::ngSQL::insertid {conn_name} {
  if {[catch {set handle [::ngBot::plugin::MySQLManager::CheckConnection $conn_name]} errorMsg]} {
    putlog "\[ngBot\] ngSQL::insertid ($conn_name): Connection check failed: $errorMsg"
    return ""
  }
  return [::mysql::insertid $handle]
}

####
# ngSQL::beginTransaction
#
# Starts a new transaction by disabling autocommit.
#
proc ::ngBot::ngSQL::beginTransaction {conn_name} {
  variable ::ngBot::plugin::MySQLManager::transaction_active
  if {[catch {set handle [::ngBot::plugin::MySQLManager::CheckConnection $conn_name]} errorMsg]} {
    putlog "\[ngBot\] ngSQL::beginTransaction ($conn_name): Connection check failed: $errorMsg"
    return [list "error" "Connection check failed: $errorMsg"]
  }
  if {[catch {::mysql::autocommit $handle 0} result]} {
    putlog "\[ngBot\] ngSQL::beginTransaction ($conn_name) Error: $result"
    return [list "error" $result]
  }
  dict set transaction_active $conn_name 1
  return 1
}

####
# ngSQL::commit
#
# Commits the current transaction.
#
proc ::ngBot::ngSQL::commit {conn_name} {
  variable ::ngBot::plugin::MySQLManager::transaction_active
  if {![dict exists $transaction_active $conn_name]} {
    return [list "error" "Cannot commit: no active transaction found for '$conn_name'"]
  }
  if {[catch {set handle [::ngBot::plugin::MySQLManager::CheckConnection $conn_name]} errorMsg]} {
    putlog "\[ngBot\] ngSQL::commit ($conn_name): Connection check failed: $errorMsg"
    return [list "error" "Connection check failed: $errorMsg"]
  }
  if {[catch {::mysql::commit $handle} result]} {
    putlog "\[ngBot\] ngSQL::commit ($conn_name) Error: $result"
    # Always re-enable autocommit and clear state
    catch {::mysql::autocommit $handle 1}
    dict unset transaction_active $conn_name
    return [list "error" $result]
  }
  # Re-enable autocommit and clear state after successful commit
  catch {::mysql::autocommit $handle 1}
  dict unset transaction_active $conn_name
  return 1
}

####
# ngSQL::rollback
#
# Rolls back the current transaction.
#
proc ::ngBot::ngSQL::rollback {conn_name} {
  variable ::ngBot::plugin::MySQLManager::transaction_active
  if {![dict exists $transaction_active $conn_name]} {
    return [list "error" "Cannot rollback: no active transaction found for '$conn_name'"]
  }
  if {[catch {set handle [::ngBot::plugin::MySQLManager::CheckConnection $conn_name]} errorMsg]} {
    putlog "\[ngBot\] ngSQL::rollback ($conn_name): Connection check failed: $errorMsg"
    return [list "error" "Connection check failed: $errorMsg"]
  }
  if {[catch {::mysql::rollback $handle} result]} {
    putlog "\[ngBot\] ngSQL::rollback ($conn_name) Error: $result"
    # Always re-enable autocommit and clear state
    catch {::mysql::autocommit $handle 1}
    dict unset transaction_active $conn_name
    return [list "error" $result]
  }
  # Re-enable autocommit and clear state after successful rollback
  catch {::mysql::autocommit $handle 1}
  dict unset transaction_active $conn_name
  return 1
}

####
# ngSQL::info
#
# Gets information about the database connection/server.
#
proc ::ngBot::ngSQL::info {conn_name option} {
  set allowed_options {
    tables databases host serverversion serverversionid
  }
  if {$option ni $allowed_options} {
    return [list "error" "Invalid option for info: '$option'"]
  }

  if {[catch {set handle [::ngBot::plugin::MySQLManager::CheckConnection $conn_name]} errorMsg]} {
    putlog "\[ngBot\] ngSQL::info ($conn_name): Connection check failed: $errorMsg"
    return [list "error" "Connection check failed: $errorMsg"]
  }

  if {[catch {::mysql::info $handle $option} result]} {
    putlog "\[ngBot\] ngSQL::info ($conn_name) Error: $result"
    return [list "error" $result]
  }
  return $result
}

# Final initialization call
::ngBot::plugin::MySQLManager::init

# --- Query Builder Object-Oriented Implementation ---
oo::class create ::ngBot::ngSQL::Query {
  variable conn_name table where_clauses

  constructor {cname tname} {
    set conn_name $cname
    set table $tname
    set where_clauses [list]
  }

  method where {column operator value} {
    lappend where_clauses [list $column $operator $value]
    return [self]
  }

  method _buildWhereClause {} {
    if {[llength $where_clauses] == 0} {
      return ""
    }
    set clauses [list]
    foreach clause $where_clauses {
      lassign $clause column operator value
      set safe_column "`[string map { "`" "``" } $column]`"
      set safe_value "'[::ngBot::ngSQL::escape $conn_name $value]'"
      lappend clauses "$safe_column $operator $safe_value"
    }
    return "WHERE [join $clauses " AND "]"
  }

  # Abstract method
  method execute {} {
    error "Execute method must be implemented by subclass"
  }
}

oo::class create ::ngBot::ngSQL::SelectQuery {
  superclass ::ngBot::ngSQL::Query
  variable conn_name table where_clauses
  variable columns limit order_by dict_format

  constructor {cname tname} {
    next $cname $tname
    set columns [list "*"]
    set order_by ""
    set limit ""
    set dict_format 0
  }

  method columns {cols} {
    set safe_cols [list]
    foreach col $cols {
      if {$col eq "*"} {
        lappend safe_cols "*"
      } else {
        lappend safe_cols "`[string map { "`" "``" } $col]`"
      }
    }
    set columns $safe_cols
    return [self]
  }

  method asDict {} {
    set dict_format 1
    return [self]
  }

  method orderBy {column {direction "ASC"}} {
    set safe_column "`[string map { "`" "``" } $column]`"
    set direction [string toupper $direction]
    if {$direction ni [list "ASC" "DESC"]} { set direction "ASC" }
    set order_by "ORDER BY $safe_column $direction"
    return [self]
  }

  method limit {count} {
    if {[string is integer -strict $count] && $count > 0} {
      set limit "LIMIT $count"
    }
    return [self]
  }

  method execute {} {
    set sql "SELECT [join $columns ", "] FROM `$table` [my _buildWhereClause] $order_by $limit"
    if {$dict_format} {
      return [::ngBot::ngSQL::sel $conn_name $sql -dict]
    } else {
      return [::ngBot::ngSQL::sel $conn_name $sql]
    }
  }
}

oo::class create ::ngBot::ngSQL::UpdateQuery {
  superclass ::ngBot::ngSQL::Query
  variable conn_name table where_clauses
  variable set_values

  constructor {cname tname} {
    next $cname $tname
    set set_values [list]
  }

  method set {data_dict} {
    dict for {key value} $data_dict {
      set escaped_value ""
      if {[::mysql::isnull $value]} {
        set escaped_value "NULL"
      } else {
        set escaped_value "'[::ngBot::ngSQL::escape $conn_name $value]'"
      }
      lappend set_values "`[string map { "`" "``" } $key]` = $escaped_value"
    }
    return [self]
  }

  method execute {} {
    if {[llength $set_values] == 0} {
      return [list "error" "Update query has no values to set"]
    }
    if {[llength $where_clauses] == 0} {
      return [list "error" "Unsafe UPDATE query: WHERE clause is missing"]
    }
    set sql "UPDATE `$table` SET [join $set_values ", "] [my _buildWhereClause]"
    return [::ngBot::ngSQL::exec $conn_name $sql]
  }
}

oo::class create ::ngBot::ngSQL::InsertQuery {
  superclass ::ngBot::ngSQL::Query
  variable conn_name table
  variable values_dict on_duplicate_update_values

  constructor {cname tname} {
    next $cname $tname
    set values_dict [dict create]
    set on_duplicate_update_values [list]
  }

  method values {data_dict} {
    set values_dict $data_dict
    return [self]
  }

  method onDuplicateUpdate {data_dict} {
    dict for {key value} $data_dict {
      lappend on_duplicate_update_values "`[string map { "`" "``" } $key]` = '[::ngBot::ngSQL::escape $conn_name $value]'"
    }
    return [self]
  }

  method execute {} {
    if {[dict size $values_dict] == 0} {
      return [list "error" "Insert query has no values"]
    }
    set cols [list]
    set vals [list]
    dict for {key val} $values_dict {
      lappend cols "`[string map { "`" "``" } $key]`"
      if {[::mysql::isnull $val]} {
        lappend vals "NULL"
      } else {
        lappend vals "'[::ngBot::ngSQL::escape $conn_name $val]'"
      }
    }
    set sql "INSERT INTO `$table` ([join $cols ", "]) VALUES ([join $vals ", "])"
    if {[llength $on_duplicate_update_values] > 0} {
      append sql " ON DUPLICATE KEY UPDATE [join $on_duplicate_update_values ", "]"
    }
    set res [::ngBot::ngSQL::exec $conn_name $sql]
    if {[lindex $res 0] eq "error"} {
      return $res
    }
    return [::ngBot::ngSQL::insertid $conn_name]
  }
}

oo::class create ::ngBot::ngSQL::DeleteQuery {
  superclass ::ngBot::ngSQL::Query
  variable conn_name table where_clauses
  method execute {} {
    if {[llength $where_clauses] == 0} {
      return [list "error" "Unsafe DELETE query: WHERE clause is missing"]
    }
    set sql "DELETE FROM `$table` [my _buildWhereClause]"
    return [::ngBot::ngSQL::exec $conn_name $sql]
  }
}


#--- PUBLIC API ---#

# Query Builder Factories
proc ::ngBot::ngSQL::select {conn_name table_name} {
  return [::ngBot::ngSQL::SelectQuery new $conn_name $table_name]
}
proc ::ngBot::ngSQL::update {conn_name table_name} {
  return [::ngBot::ngSQL::UpdateQuery new $conn_name $table_name]
}
proc ::ngBot::ngSQL::insert {conn_name table_name} {
  return [::ngBot::ngSQL::InsertQuery new $conn_name $table_name]
}
proc ::ngBot::ngSQL::delete {conn_name table_name} {
  return [::ngBot::ngSQL::DeleteQuery new $conn_name $table_name]
}